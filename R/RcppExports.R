# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title
#' Zip sorted arrays against each other
#' @description
#' Given two sorted arrays, \eqn{x} and \eqn{y}, find indices \eqn{L} that \sQuote{zips}
#' the two together. 
#' 
#' @param sortx a sorted array of \sQuote{reference} values.
#' @param looky a sorted array of values whose place among \code{sortx} is to be found.
#'
#'
#' @details
#'
#' For example, for \code{zip_le}, we find the array \eqn{L} of the
#' same length as \eqn{y} such that there are exactly \eqn{L_i} elements of \eqn{x}
#' less than or equal to \eqn{y_i}.
#'
#' @return a vector, filled out as follows:
#' \describe{
#' \item{zip_le}{Returns the vector \eqn{L} such that there are exactly \eqn{L_i} elements of \eqn{x} less than or equal to \eqn{y_i}.}
#' \item{zip_lt}{Returns the vector \eqn{L} such that there are exactly \eqn{L_i} elements of \eqn{x} less than \eqn{y_i}.}
#' }
#'
#' @note
#' Returns zero when there are none, as expected.
#'
#' @examples
#' set.seed(1234)
#' x <- sort(rnorm(1e5))
#' y <- sort(rnorm(1e2))
#' idx1 <- zip_le(x,y)
#' # slow way, should give the same answer
#' uther <- rep(NA,length(y))
#' for (iii in 1:length(y)) {
#'   uther[iii] <- sum(x <= y[iii])
#' }
#'
#' @note it would be better if this code supported mixed types of sortx and looky.
#' @template etc
#' @name zipsorted
#' @rdname zipsorted
#' @export
zip_le <- function(sortx, looky) {
    .Call('zipper_zip_le', PACKAGE = 'zipper', sortx, looky)
}

#' @rdname zipsorted
#' @export
zip_lt <- function(sortx, looky) {
    .Call('zipper_zip_lt', PACKAGE = 'zipper', sortx, looky)
}

