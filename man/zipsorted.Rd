% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{zipsorted}
\alias{zipsorted}
\alias{zip_le}
\alias{zip_lt}
\title{Zip sorted arrays against each other}
\usage{
zip_le(sortx, looky)

zip_lt(sortx, looky)
}
\arguments{
\item{sortx}{a sorted array of \sQuote{reference} values.}

\item{looky}{a sorted array of values whose place among \code{sortx} is to be found.}
}
\value{
a vector, filled out as follows:
\describe{
\item{zip_le}{Returns the vector \eqn{L} such that there are exactly \eqn{L_i} elements of \eqn{x} less than or equal to \eqn{y_i}.}
\item{zip_lt}{Returns the vector \eqn{L} such that there are exactly \eqn{L_i} elements of \eqn{x} less than \eqn{y_i}.}
}
}
\description{
Given two sorted arrays, \eqn{x} and \eqn{y}, find indices \eqn{L} that \sQuote{zips}
the two together.
}
\details{
For example, for \code{zip_le}, we find the array \eqn{L} of the
same length as \eqn{y} such that there are exactly \eqn{L_i} elements of \eqn{x}
less than or equal to \eqn{y_i}.
}
\note{
Returns zero when there are none, as expected.

it would be better if this code supported mixed types of sortx and looky.
}
\examples{
set.seed(1234)
x <- sort(rnorm(1e5))
y <- sort(rnorm(1e2))
idx1 <- zip_le(x,y)
# slow way, should give the same answer
uther <- rep(NA,length(y))
for (iii in 1:length(y)) {
  uther[iii] <- sum(x <= y[iii])
}

}
\author{
Steven E. Pav \email{shabbychef@gmail.com}
}
